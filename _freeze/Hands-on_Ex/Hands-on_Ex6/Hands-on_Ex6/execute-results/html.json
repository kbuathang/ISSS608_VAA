{
  "hash": "9792bdc4107174052d4b3e6d54205faa",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 6:Visualising and Analysing Time-oriented Data\"\ndate: February 22,2024\ndate-modified: \"last-modified\"\ntoc: true\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n  message: false\ncode-fold: false\ncode-summary: \"Show the code\"\n---\n\n\n# 1 Getting Started\n\nIn this exercise, we will use the following our R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.\n\n::: panel-tabset\n## Loading R package\n\nThe code chunk below uses `p_load()` of pacman package to check if these packages are installed in the computer and load them onto your working R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n## Importing Data\n\nThe code chunk below imports eventlog.csv into R environment by using `read_csv()` function of [readr](https://readr.tidyverse.org/) package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n## Examining the data structure\n\nNext, we will use `kable()` to review the structure of the imported data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n:::\n:::\n\n\nThere are three columns which are *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in POSIXct format.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n\n## Preparing Data\n\n### 1. Deriving weekday and hour of day fields\n\nWe need to derive two new fields which are *wkday* and *hour* before we can plot the calendar heatmap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n::: {.callout-note appearance=\"simple\" icon=\"false\"}\n## Note\n\n-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n\n-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.\n:::\n\n### 2. Deriving the attacks tibble data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n::: {.callout-note appearance=\"simple\" icon=\"false\"}\n## Note\n\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they will be ordered when plotting.\n:::\n\n## Final dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n:::\n:::\n\n:::\n\n# 2 Calendar Heatmaps\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"yellow\", \n                    high = \"red\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex6_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: callout-tip\n## Things to learn from the code chunk\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\n# 3 Multiple Calendar Heatmaps\n\n## 3.1 Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, we need to do the followings:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attackes by country, and\n\n-   save the results in a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n## 3.2 Preparing the tidy data frame\n\nWe have to extract the attack records of the top 4 countries from *attacks* data frame and save the data in a new tibble data frame (i.e. *top4_attacks*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n## 3.3 Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"yellow\", \n                    high = \"red\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex6_files/figure-html/unnamed-chunk-10-1.png){width=1152}\n:::\n:::\n\n\n# 4 Cycle Plot\n\nIn this section, we will plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n## 4.1 Data Import\n\nThe code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and save it as a tibble data frame called *air*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n## 4.2 Deriving month and year fields\n\nIn this step, we will derive two new fields called *month* and *year* are derived from *Month-Year* field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n## 4.3 Extracting the target country\n\nNext, the code chunk below is use to extract data for the target country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n## 4.4 Computing year average arrivals by month\n\nThe code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n## 4.5 Plotting the cycle plot\n\nThe code chunk below is used to plot the cycle plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month, scales = \"free_y\") +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex6_files/figure-html/unnamed-chunk-15-1.png){width=1728}\n:::\n:::\n\n\n# 5 Slopegraph\nIn this section we will plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\n## 5.1 Data Import\nImport the rice data set into R environment by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n## 5.2 Plotting the slopegraph\nNext, code chunk below will be used to plot a basic slopegraph as shown below\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = NULL)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex6_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: callout-tip\n## Things to learn from the code chunk\n\nFor effective data visualization design, `factor()` is used convert the value type of Year field from numeric to factor\n:::",
    "supporting": [
      "Hands-on_Ex6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}